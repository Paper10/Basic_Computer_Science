# HTTP/1.0

**하나의 연결당 하나의 요청**을 처리하도록 설계된 프로토콜이다. 서버로부터 파일을 가져올때마다 발생하는 3-way handshake로 인한 **RTT가 매우 크다**는 단점이 있다.

-> **RTT** : 전송한 패킷이 목적지에 도달 후에 **다시 돌아오는데 걸리는 시간**

## RTT증가를 해결하는 방법

서버에 요청하는 **파일을 줄이는** 방법으로 해결 가능하다. 이를 위해 **이미지 스플리팅**, **코드 압축**, **이미지 base64 인코딩**등이 사용된다

### 이미지 스플리팅

복수의 이미지를 **하나의 Background 이미지로 합치고** 특정 이미지의 **위치정보**를 함께 전송하는 방법이다.

### 코드 압축

전송하는 코드에서 **개행문자와 띄어쓰기를 삭제**하여 코드파일의 크기를 줄이는 방법이다.

### 이미지 Base64 인코딩

이미지를 **64비트의 문자열**로 인코딩하여 별도의 **이미지 요청을 없애는 방법**이다. 이 방법으로 서버에 전달되는 **요청의 개수는 감소**하지만 파일의 **크기가 약 40% 증가**된다.

# HTTP/1.1

HTTP 1.0 버전에서 매 요청마다 TCP 연결을 시작하던 방법에서 한번 서버와 **TCP 연결을 시작**하면 **keep-alive 옵션**을 추가하여 **옵션이 지속되는 동안** 별도의 추가 **TCP연결 없이 파일을 전송**할 수 있도록 하는 방법이다.

## HOL Blocking

1.1버전에서의 단점으로 전송하는 파일 중 **특정 파일의 크기가 클 경우** **해당 파일보다 늦게 전송된 파일**들이 **해당 파일이 전송되기 전까지 전송되지 못하는 현상**이다.

## 무거운 헤더 구조

첫 TCP 연결에서 전송해야하는 **파일들의 메타데이터**가 전부 **압축없이** 포함되어 헤더가 매우 **무거워진다**는 단점이 있다.

# HTTP/2

**멀티플렉싱, 헤더압축, 서버푸시, 요청의 우선순위 처리** 등 기술로 **지연시간**을 줄이고 **응답시간**을 빠르게한 버전이다.

## 멀티플렉싱

**여러개의 스트림**을 사용하여 송수신을 진행하는 방법으로 하나의 스트림에 전송되는 데이터 또한 **여러 프레임으로 분해** 한 후 수신부에서 재조립하여 사용한다 . 특정 스트림이 손상되어도 **다른 스트림의 패킷에 영향을 미치지 않는다**.

## 헤더 압축

**허프만 코딩 압축 알고리즘**을 사용하여 **HPACK**형식으로 헤더를 압축하여 전송한다

### 허프만 코딩 압축 알고리즘

문자열을 **문자단위**로 쪼갠 후에 **문자들의 빈도수**를 세어 문자가 **빈번하게 나타날수록 적은 비트수**를 사용하여 전체 문자열의 비트 **크기를 줄이는** 알고리즘이다.

## 서버 푸시

서버가 **html등의 파일을 전송**할 떄 **html에 포함된** 이미지파일이나 자바스크립트 코드 등의 **추가 파일**을 **별도의 요청없이** 함께 전송하는 방법이다. 

# HTTPS

어플리케이션 계층 위에서만 동작하는 **HTTP**에 **어플리케이션과 전송계층 사이**에 **신뢰계층**인 **SSL/TLS 계층**이 추가된 **신뢰성이 높은 HTTP**이다

## SSL/TLS( Secure Socket Layer/Transport Layer Security protocol )

**전송계층**에서 **보안**을 제공하는 프로토콜로 제3자가 메세지를 도청하거나 변조하지 못하도록 방지한다. 

보안세션을 기반으로 데이터를 암호화 하며 **인증 메커니즘, 키 교환 암호화 메커니즘, 해싱 알고리즘**을 사용하여 보안세션을 구성한다. 

-> **보안 세션** : **보안이 시작되고 끝나는 동안만 유지**되는 일시적인 세션이다. SSL/TLS는 이 세션을 통해 상태를 공유한다

-> **세션** : 운영체제가 **자신의 자산 이용을 허락**하는 일정 기간.

HTTPS의 보안 세션 handshake는 다음과 같이 이루어진다.

1. 클라이언트가 서버에게 **사이퍼 슈트**를 전달한다
2. 서버에 해당 사이퍼 슈트가 존재하면 클라이언트로 **인증서**를 전달한다
3. 해당 인증서를 통해 인증 메커니즘이 시작된다.
4. 이후 암호화 통신이 시작된다

### 사이퍼 슈트

**프로토콜, AEAD 사이퍼모드, 해싱 알고리즘**이 나열된 **규약**이다. 해당 규약에 따라 데이터 교환이 이루어진다

-> **AEAD 사이퍼 모드** : 데이터 암호화 알고리즘

### 인증 메커니즘

**CA( Certificate Authorities )**에서 발급한 인증서를 기반으로 이루어진다. 이 **인증서는** 연결에 필요한 **공개키**를 클라이언트에 제공하고 해당 서버가 **신뢰할 수 있는** 서버임을 보장하며 **서비스정보, 공개키, 지문, 디지털 서명**등으로 이루어져 있다. 엄격하게 공인된 **기업**만이 CA의 역할을 수행할 수 있다.

CA인증서를 발급받기 위해서는 자신의 **사이트 정보**와 **공개키**를 CA에 제출해야 한다. CA는 **공개키를 해시**하여 **지문**을 생성하고 **CA의 비밀키**를 활용하여 CA인증서를 발급한다.

-> **개인키** : **비밀키**라고도 불리며 **개인 자신만이** 소유해야 하는 키

-> **공개키** : 공개되어 있는 키

### 암호화 알고리즘

키 교환 알고리즘에는 ECDHE, DHE 등이 있으며 이러한 알고리즘 모두 **디피-헬만 알고리즘**을 기반으로 만들어졌다

### 디피-헬만 키 교환 알고리즘

y=g^x(mod(p)) 식에 기반한 알고리즘으로 서버와 클라이언트만이 공유하는 **공통의 암호키**를 생성하는 방법이다. 공개키와 양측의 비밀값이 전부 있어야 하기때문에 외부의 제3자가 데이터를 훔치기 어렵다. 아래 순서에 따라 진행된다.

1. 서버와 클라이언트가 **공유하는 특정 값**을 설정한다
2. 서버,클라이언트 각각이 소유한 **비밀 값**과 혼합하여 각자의 값을 만들어낸다
3. 만들어낸 값을 **서로에게 전달**한다
4. 전달받은 값을 다시 **각자의 비밀값과 혼합**하면 서버와 클라이언트의 **공통의 암호키 PSK( Pre-Shared Key )**가 생성된다
5. 공통의 암호키는 **(공유하는 특정값 + 클라이언트의 비밀값 + 서버의 비밀값 )** 과 같다

### 해싱 알고리즘

데이터를 **더 작고 섞여있는 조합**으로 만드는 알고리즘으로 데이터를 **256비트의 데이터 조합**으로 변환하는 **SHA-256 알고리즘**이 대표적이다.

